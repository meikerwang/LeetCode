# 并查集

## 1. Quick Find 并查集


查询时间复杂度O(1)

合并的时间复杂度O(n)

对于节点数很多数据量大, 合并速度会很慢


## 2. Quick Union 并查集

以树形结构形式存储节点

合并和查询的时间复杂度都是O(h), 其中h是树的高度

牺牲了一点查找性能, 提高了合并的性能, 但是整体性能可能较差


## 3. 基于 size 的优化

使用 size 数组, 记录每个根节点的大小, 因此合并时节点个数少的往节点个数多的树去合并, 降低每科树的高度


## 4. 基于 rank 的优化

基于size的优化方案, 是节点数少的树往节点数多的树合并, 但是节点数多不代表树的高度高

基于rank的优化方案, rank代表数的高度或深度. 高度低的树向高度高的树合并


## 5. 路径压缩优化

路径压缩基于size的基础上来做优化的. 优化时机是在执行 find操作 的时候对其进行路径压缩

不同的二叉树的查询和合并的时间复杂度是O(log(n)), 但是并查集是一个多叉树

加上size和路径压缩优化后, 并查集的时间复杂度为O(log*(n)), 比O(log(n))快, 近似等于O(1), 稍微慢一点

在 65536 < n <= 2^65536时, log*(n) = 5