# 并查集

## 并查集优化
### 1. Quick Find 并查集


查询时间复杂度O(1)

合并的时间复杂度O(n)

对于节点数很多数据量大, 合并速度会很慢


### 2. Quick Union 并查集

以树形结构形式存储节点

合并和查询的时间复杂度都是O(h), 其中h是树的高度

牺牲了一点查找性能, 提高了合并的性能, 但是整体性能可能较差


### 3. 基于 size 的优化

使用 size 数组, 记录每个根节点的大小, 因此合并时节点个数少的往节点个数多的树去合并, 降低每科树的高度


### 4. 基于 rank 的优化

基于size的优化方案, 是节点数少的树往节点数多的树合并, 但是节点数多不代表树的高度高

基于rank的优化方案, rank代表数的高度或深度. 高度低的树向高度高的树合并


### 5. 路径压缩优化

路径压缩基于size的基础上来做优化的. 优化时机是在执行 find操作 的时候对其进行路径压缩

不同的二叉树的查询和合并的时间复杂度是O(log(n)), 但是并查集是一个多叉树

加上size和路径压缩优化后, 并查集的时间复杂度为O(log*(n)), 比O(log(n))快, 近似等于O(1), 稍微慢一点

在 65536 < n <= 2^65536时, log*(n) = 5



## 题目

[990. 等式方程的可满足性](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/): 各个变量看成图的节点, 等价关系看成两个边, 等价关系具有传递性, 因此等价的变量属于同一个连通分量, 可以使用并查集维护这种连通分量


[1319. 连通网络的操作次数](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/): 网络各个节点之间是否相互连接, 求连通分量的数量, 而并查集本身就是用来维护连通性的数据结构

